/ *! jQuery v1.12.0 | (c) Fundación jQuery | jquery.org/license * /
! la función (a, b) {"objeto" == módulo typeof && "objeto" == typeof module.exports module.exports = a.document b (a, 0!):?! función (a) {if (un .document) throw new Error ("jQuery requiere una ventana con un documento"); b retorno (a)}:!? b (a)} ("undefined" = ventana typeof ventana: esto, la función (a, b) { var nuevo e.call (este)}, obtener: function (a) {return null = a 0> a esto [a + this.length]:?!? esta [a]: e.call (este)}, pushStack: función (a) {var b = n.merge (this.constructor (), a); volver b.prevObject = esto, b.context = this.context, b}, cada uno: la función (a) {n.each retorno ( esto, a)}, el mapa: función (a) {return this.pushStack (n.map (esto, la función (b, c) {return a.call (b, c, b)}))}, rebanada: función () {return this.pushStack (e.apply (este, argumentos))}, primero: function () {return this.eq (0)}, última: function () {return this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + (0> a b: 0); volver this.pushStack (? c> = 0 && b> c [este [c]]: []) }, final: function () {return a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = arguments.length, j = 1;! a ("booleano" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "objeto" == typeof g || n.isFunction (g) || (g = {}), h === i && (g = esto, h -); i> h; h ++) si (null = (e = argumentos [h])) de (d adentro! 0 == c && (g [d] = c)); retorno g}, n.extend ({expando: "jQuery" + (m + Math.random ()). Replace (/ \ D / g "," ), isReady: 0, error: function (a) {throw new ! nula = a && un a.window ==}, isNumeric: function (a) {var b = a && a.toString (); volver n.isArray (a) && b-parseFloat (b) 1> = 0}, isEmptyObject: función (a) {var b; for (b en a) devuelve 1; return 0!}, isPlainObject: function (a) {var en a) k.call retorno (a, b), porque (b en a); volverá vacía k.call 0 === b || (a, b)}, escriba: función (a) {return null == ? a a + "": "objeto" == typeof a || "función" == typeof una i [j.call (a)] ||? "objeto": typeof a.replace (p, "ms -") reemplazará (q, r)}, nodeName:. función (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada uno : function (a, b) {var c, d = 0; si (s (a)) {for (c = a.length; c> d; d ++) si (b.call (a [d], d, un [d]) === 1) ruptura} else for (d en a) si (b.call (a [d], d, un [d]) === 1) break;! volver a}, recortar: function (a) {return null == un "" :( a + "") reemplazar (o, "")?.}, MakeArray: function (a, b) {var c = b || []; retorno ! nula = a && (s (Object (a)) n.merge (c, "cadena" == typeof un [a]:?? a): g.call (c, a)), c}, InArray: función (a, b, c) {var d, y si (b) {if (h) h.call retorno (b, a, c), porque (d = b.length, c = c 0> c Matemáticas??. max (0, d + c): c: 0; d> c, c ++) si (c en b && b [c] === a) la devolución c} return-1}, fusionar: function (a, b) {var c = + b.length, d = 0, e = a.length, mientras que (c> d) a [e ++] = b [D] ++; (! c == c) si, mientras que (void 0 == b [! d]) a [e ++] = b [D ++]; retorno a.length = e, a}, grep: function (a, b, c) {for (var d, e = [], f = 0, g = ! a.length, h = c; g> f; f ++) d = b (a [f], f), d == h && e.push (a [f]); retorno e}, el mapa:! la función ( a, b, c) {var d, e, g = 0, h = []; si (s (a)) de (d = a.length; d> g; g ++) e = b (a [g] , g, c), null = e && h.push (e);! else for (g en a) e = b (a [g], g, c), null = e && h.push (e);! retorno f. aplicar ([], h)}, guid: 1, delegación: function (a, b) {var c, d, f, volver "cadena" == typeof b && (f = a [b], b = a, a = f), n.isFunction (a)? (c = e.call (argumentos, 2), d = function () {return a.apply (b || esto, c.concat (e.call (argumentos)) )}, d.guid = a.guid = a.guid || n.guid ++, d): void 0}, ahora: function () {return + nueva fecha}, el apoyo: l}), "función" == typeof símbolo && (n.fn [Symbol.iterator] = c [Symbol.iterator]), n.each ("Número de Boole Cadena función array Fecha RegExp objeto Error Símbolo" .split (""), la función (a, b) { i ["[objeto" + b + "]"] = b.toLowerCase ()}); la función s (a) {var b = !! un && "longitud" en un a.length &&, c = n.type (a); "función" de retorno === c || n.isWindow (a) ?! 1: "matriz" === c || 0 === b || "número" == typeof b && b> 0 && b-1 en un} var t = function (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = " chisporrotear "+ 1 * new Date, v = a.document, w = 0, x = 0, y = ga (), z = ga (), A = ga (), B = function (a, b) {return c = 0, d = a.length; d> c, c ++) si (a [c] === b) la devolución RegExp (L + "+", "g"), Q = new RegExp ("^" L + + "+ | ((:? ^ | [^ \\\\]) (: \\\\) *). "+ L +" + $ "," g "), R = new RegExp (" ^ "+ L +" * "+ L +" * "), S = new RegExp (" ^ "L + +" * ([> + ~] | "+ L +") "L + +" * "), T = new RegExp (" = "L + +" * ([^ \\] '\ L + + "* \\]" "] *)?" , "g"), T = new RegExp (O), V = new RegExp ("^" + M + "$"), W = {ID: nueva RegExp ("^ # (" + M + ")"), CLASE : nueva RegExp ("^ \\ (". + M + ")"), TAG: nueva RegExp ("^ (" + M + "| [*])"), attr: nueva RegExp ("^" + N), PSEUDO: nueva RegExp ("^" + O), NIÑO: nueva RegExp ("^ (?:" + K + ") $", "i"), needsContext: nueva \ w /, $ = / ^ (?:. # ([\ w -] +) | (\ w +) | \ ([\ w -] +)) $ /, _ = / [+ ~] /, aa = / '| \\ / g, ba = new RegExp ("\\\\ ([\\ da-f] {1,6}" + L + "|? (" L + + ") |.)", " ig "), ca = function (a, b, c) {var d =" 0x "+ b-65536; retorno c = a.length, d = 0, mientras que (a [c ++] = b [d ++]); a.length = c-1}}} fa función (a, b, d, e) {var f, h, j, k, l, o, r, s, w = b && b.ownerDocument, x = b b.nodeType:?! 9; si (d = d || [], "cadena" = typeof a || a | |!!! 1 == x && 9 == x && 11 == x) de retorno d; si (j.id === f) la devolución d.push (j), d} else if (w && (j = w.getElementById (f)) && t (b, j) && j.id === f) volver d.push (j), d} else {if (o [2]) return H.apply (d, b.getElementsByClassName (f)), d} if (c.qsa &&! A [a + ""] && (! Q ||! Q.test (a))) {if (1 == x) w = b, s = a; lo demás "+ qa (r [h]); s = r.join (", "), w = _ de prueba (a) && OA (b.parentNode) || b} if (s) tratan {return H.apply (. d, w.querySelectorAll (s)), d} catch (y) {} finally {k === u && b.removeAttribute ("id")}}} return i (a.replace (Q, "$ 1"), b , d, e)} ga function () {var a = []; la función b (c, e) {a.push retorno (c + "")> d.cacheLength && eliminar b [a.shift ()], b [c + ""] = e} return b} function ha (a) {return un [u] = 0, un} function ia (a) {var ja (a, b) {var c = a.split ("|"), e = c.length, mientras que (e -) d.attrHandle [c [e]] = b} function ka (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~ b.sourceIndex || C) - (~ a.sourceIndex || C), si (d) la devolución d; si ( c) mientras (c = c.nextSibling) si (c === b) devuelven-1; devolver un 1: la (a) {retorno de la función -1} function (b) {var c = b.nodeName.toLowerCase (); return "entrada" === c && b.type === a}} ma función (a) {retorno de la función (b) {var c = b.nodeName.toLowerCase (); return ("entrada" === "botón" c || === c) && b.type === a}} funcionar na (a) {return hectáreas (function (b) {return b = + b, ja (function (c, d) {var e, f = a ([], c.length, b), g = f.length;! while (g -) c [e = f [g]] && (c [e] = (d [e] = c [e]))})})} function OA (a) {return un && "undefined"! = typeof a.getElementsByTagName && a} c = fa.support = {}, f = fa.isXML = function (a) { var b = a && (a.ownerDocument || a) .documentElement; retorno b "HTML" == b.nodeName:?!! 1}, m = fa.setDocument = function (a) {var b, e, g = ? un a.ownerDocument || a: v; retorno a.className = "i",! a.getAttribute ("className")}), c.getElementsByTagName = ia (function (a) {return b.getElementById && p) {var c = b.getElementById (a); retorno c [c]: []}}, d.filter.ID = function (a) {var b = a.replace (BA, CA); función de retorno (a) {return a.getAttribute ("id") === b}}) :( eliminar d.find.ID, d.filter.ID = function (a) {var b = a.replace (ba , ca); la función de retorno (a) {var c = "undefined" = typeof a.getAttributeNode && a.getAttributeNode ("id");! devolver c && c.value === b}}), d.find.TAG = c. getElementsByTagName función (a, b) {return "indefinido" = typeof b.getElementsByTagName b.getElementsByTagName (a):?!? c.qsa b.querySelectorAll (a): void 0}: la función (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a), si ("*" === a) {while (c = f [e ++]) 1 === d.push c.nodeType && ( !? c); retorno d} return f}, d.find.CLASS = c.getElementsByClassName && función (a, b) {return "indefinido" = typeof b.getElementsByClassName && p b.getElementsByClassName (a): void 0}, r = [ ], q = [], (c.qsa = Z.test (n.querySelectorAll)) && (ia (function (a) {o.appendChild (a) .innerHTML = "<a id = '" + u + "' > </a> <select id = '"+ u +" - \ r \\' msallowcapture = ''> <option RegExp (q.join ("|")), r = r.length && nueva RegExp (r.join ("|")), b = Z.test (o.compareDocumentPosition), t = b || Z.test (o ?? .contains) función (a, b) {var c = 9 === a.nodeType a.documentElement: a, d = b && b.parentNode; retorno l = 0,0;!!! var d = a.compareDocumentPosition- b.compareDocumentPosition; retorno l = 0,0;! var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; (! e || f) si volver a = ? n == -1: b === n 1: e -1: f 1: k J (k, a) -J (k, b):???? 0; si (e === f) regreso d ka (g [d], h [d]):? g [d] === v -1: h [d] === v 1: 0}, n): n}, fa.matches = function (a, b) {return (! r || r.test (b)) (! q || q.test (b)) "] && &&) try {var d = s.call (a, b), si (d || a.document c.disconnectedMatch || && 11! == a.document.nodeType) retorno d} catch (e) {} return e = d.attrHandle [b.toLowerCase ()], f = e && D.call (d.attrHandle, b.toLowerCase ()) e (a, b, p!): void 0; retorno vacío nuevo error ("Error de sintaxis, la expresión no reconocido:" + a)}, fa.uniqueSort = function (a) {var k = null, a}, e = fa.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; si (f) {if (1 === f || 9 === f || 11 === f) {if ("cadena" == typeof a.textContent) volver a.textContent; para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) volver a.nodeValue} else while (b = a [d ++]) c + = e (b); retorno a [1] = a [1] .Colocar (ba, ca), un [3] = (a [3] || un [4] || un [5] || ""). reemplazar (ba, ca ), "~ =" === un [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)}, NIÑO: function (a) {return b, c = a [6] && un [2];! devolución b = a.replace (ba, ca) .tolowercase (); return "*" === una función () {return 0!}: function (a) {return a.nodeName && a.nodeName.toLowerCase () ==? = b}}, CLASE: function (a) {var b = y [a + ""]; retorno b || (b = new RegExp ("(^ |" + L + ")" + a + "(" + L + " | $) ")) && y (a, la función (a) {return b.test (" cadena "== typeof a.className && a.className ||" indefinido de clases ")" = typeof a.getAttribute && a.getAttribute (! "| | "")})}, ATTR: function (a, b, c) {función de retorno (d) {var e = fa.attr (d, a); retorno "+ e.replace (P," ") +" ! f = "enésima" == a.slice (0,3), g = "último" == a.slice (-4), h = "del tipo" === b;! devolver 1 === ? d && 0 === e función (a) {return !! a.parentNode}: function (b, c, i) {var t = e, t === d || t% d === 0 && t / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || fa.error ("pseudo sin apoyo:" + a);?? vuelta de correo [u] e (b): e.length> 1 (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ()) ha (función (a, c) {var d, f = e (a, b), g = f.length;? while (g- -) d = J (a, f [g]), un [d] = (c [d] = f [g])}): function (a) {return correo (a, 0, c)})! : e}}, pseudos: {No: ja (function (a) {var b = [], c = [], d = h (a.replace (Q, "$ 1")); retorno d [u]? ha (función (a, b, c, e) {var f, g = d (a, null, e, []), h = a.length; while (h -) (f = g [h]) && (a [h] = (b [h] = f)!)}): function (a, e, f) {return b [0] = a, d (b, null, f, c), b [ 0] = null, c.pop ()}}), cuenta con: ja (function (a) {retorno de la función (b) {return fa (a, b) .length> 0}}), contiene: ja (función (un retorno V.test (a || "") || fa.error ("sin soporte lang:" + a), a = a.replace (ba, ca) .tolowercase (), función (b) {var c; hacer si (c = p b.lang:? b.getAttribute ("xml: lang") || b.getAttribute ("lang")) return c = a.location && a.location.hash; regresar c && c.slice (1) === b.id}, raíz: function (a) {return una o ===}, enfoque: función (a) {return ! a.disabled === 1}, discapacitados: function (a) {return a.disabled === 0}, comprobado: la función (a) {var Y.test (a.nodeName)}, de entrada: function (a) {return X.test (a.nodeName)}, un botón: function (a) {var b = a.nodeName.toLowerCase (); return "de entrada" === b && "botón" === a.type || "botón" === b}, texto: function (a) {var c = 0; b> c; c + = 2) a.push (c); volver a}), impar: na (function (a, b) {for (var c = 1; b> c; c + = 2) a.push (c); volver a}), lt: na (function (a, b, c) {for (var d = 0> c c + b: c; - d> = 0;) a. push (d); volver a}), gt: na (function (a, b, c) {for (var d = 0> c c + b: c; ++ d <b;) a.push (d ); volver a})}}, d.pseudos.nth = d.pseudos.eq; for (b {en la radio:!!!!! 0, casilla: 0, archivo: 0, contraseña: 0, imagen: 0 }) d.pseudos [b] = la (b), por (b en {presentar: 0, reset: 0}) d.pseudos [b] = ma (b); pa función () {} pa. prototipo = d.filters = d.pseudos, d.setFilters = new pa, g = fa.tokenize = function (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; si (k) de retorno ")}), h = h.slice (c.length)); for (g en ? b h.length: h fa.error (a): z (a, i) .slice (0)}; función qa (a) {for (var b = 0, c = a.length, d = " "; c> b; b ++) d + = a [b] .value; retorno d} ra la función (a, b, c) {var d = b.dir, e = c &&" parentNode "=== d, f = x ++; volver b.first función (b, c, f) {while (b = b [d]) si (1 === b.nodeType || e) volver a (b, c, f)}: función? (b, c, g) {var h, i, j, k = [w, f]; si (g) {while (b = b [d]) if ((1 === b.nodeType || e ) && a (b, c, g)) devuelven 0} else k [2] = h [2]; if (! i [d] = k, k [2] = a (b, c, g)) return 0}}} function sa (a) {a.length retorno> ? 1 función (b, c, d) {; - (! un [e] (b, c, d))! var e = a.length mientras que (e) si regresan 1; return 0}: a [ 0]} function ta (a, b, c) {for (var d = 0, e = b.length; e> d; d ++) fa (a, b [d], c); retorno c} function ua ( a, b, c, d, e) {for (var f, g = [], h = 0, i = a.length, j = null = b;! i> h; h ++) (f = a [h ]) && (c || c (f, d, e!)) && (g.push (f), j && b.push (h)); retorno g función} va (a, b, c, d, e, f) {return d &&! d [u] && (d = VA (d)), e &&! e [u] && (e = VA (e, f)), ja (function (f, g, h, i) {var r = ua (r === g r.splice (o, r.length):? r), correo electrónico (null, g, r, i):? H.apply (g, r)})} wa función (a) {for (var b, c, e, f = a.length, g = d.relative [a [0] .type], h = g || d.relative [""], i = g? 1: 0, k = ra (! función (a) {return un === b}, h, 0), L = ra (function (a) {return J (b, a)> - 1}, h, 0), m = [función (a, c, d) {var e =! g && (d || c! == j) || ((b = c)? k .nodeType (a, c, d) : l (a, c, d)); retorno VA (i> 1 && sa (m), i> 1 && qa (a.slice (0, i-1) .concat ({valor: " xa sa} function (m) (a, b) {var c = b.length> 0, e = a.length> 0, f = function (f, g, h, i, k) {var k && (w = y, j = v), t}; regresar c ha (f): f} return h = fa.compile = function (a, b) {var c, d = [], e = []? , f = A [a + " f}, i = fa.select = function (a, b, e, f) {var i, j, k, l, m, n = "función" == typeof 1 & a.compareDocumentPosition (n.createElement ("div"))}), ia (function (a) {return a.innerHTML = "<a ? c nula 0: a.getAttribute (b, "tipo" === b.toLowerCase () 1: 2)}), ia c.attributes && (function (a) {return c || "entrada" == a.nodeName.toLowerCase () void 0:!? a.defaultValue}), ia (function (a) {return null == a.getAttribute ("disabled")}) || ja (K, la función (a, b, c) {var d; c retorno vacío? u = función (a, b, c) {var d = [], e = 0 void == c;! while (! (a = a [b]) && 9 == a.nodeType) si (1 === a.nodeType) {if (e && n (a) .es (c)) romper; d.push (a)} return d}, v = function (a, b) {for (var c = []; a; un = a.nextSibling) 1 === a.nodeType && a == b && c.push (a); retorno c}, w = n.expr.match.needsContext, x = / ^ <([\ w -] +) \! ? s * \ /> (:? <\ / \ 1> |) $ /, y = / ^ [^: # \ [\,] * $ /; función z (a, b, c) {if.. (n.isFunction (b)) n.grep retorno (a, la función (a, d) {return !! b.call (a, d, a) == c!}); si (b.nodeType) return n .grep (a, la función (a) {return una === b == c!}); si ("cadena" == typeof b) {if (y.test (b)) n.filter retorno (b, a, c); b = n.filter (b, a)} n.grep retorno (a, la función (a) {return n.inArray (a, b)> - 1 == c})} n.filter! = function (a, b, c) {var d = b [0]; retorno 1 === a.nodeType}))}, n.fn.extend ({encontrar: function (a) {var b, c = [], d = este, e = D.Longitud; si ("cadena"! = typeof a) la devolución c = this.pushStack (? e> 1 n.unique (c): c), c.selector = this.selector this.selector + "" + a:? a, c}, filtro: la función (a) {return este .pushStack (z (esto, a || [] ,! 1))}, no: la función (a) {return this.pushStack (z (esto, a || [] ,! 0))}, es: la función (a) {return !! z (this, "cadena" == typeof un && w.test (a) n (a):? a || [] ,! 1) .length}}); var A, B = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, C = n.fn.init = function (a, b , c) {var e, f,! si (a) regrese esta; si (c = c || A, "cadena" == typeof en vez de en b) n.isFunction (esto [e]), este [e] (b [e]):? this.attr (e, b [e]); devuelva este} if (f = d.getElementById (e [2 ]), f && f.parentNode) {if (f.id == e [2]) volver A.find (a);! this.length = 1, esto [0] = f} volver this.context = d, este .Selector = a, esto} return a.nodeType (this.context = esta [0] = a, this.length = 1, este):? n.isFunction (a) "indefinido" = typeof c.ready?!? c.ready (a): un (a) :( vacío b, c = n (a, este), d = c.length; retorno c, d = 0, e = this.length, f = [], g = w.test (a) || "cadena"! = typeof push (c);} ruptura volver this.pushStack (? f.length> 1 n.uniqueSort (f): f)}, índice: function (a) {return una "cadena" == typeof? this.pushStack (n.uniqueSort (n.merge (this.get (), n (a, b))))}, addBack: function (a) {return this.add (null == un this.prevObject?: ! this.prevObject.filter (a))}}); función F (a, b) {hacer a = a [b], mientras que (a && 1 == a.nodeType); volver a} n.each ({padre: función (a) {!? var b = a.parentNode; retorno b && 11 == b.nodeType b: null}, los padres: la función (a) {return u (a, "parentNode")}, parentsUntil: función (a, b, c) {return u (a, "parentNode", c)}, al lado: function (a) {return F (a, "nextSibling")}, prev: function (a) {return F (a previousSibling, " ")}, nextAll: function (a) {return u (a," nextSibling ")}, prevAll: function (a) {return u (a," previousSibling ")}, nextUntil: function (a, b, c) {return u (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return u (a, "previousSibling", c)}, hermanos: function (a) {return v ((a .parentNode || {}) firstChild, a)}, los niños:. función (a) {return v (a.firstChild)}, contenidos: function (a) {return e = n.map (esto, b, c);! retorno "Hasta" == a.slice (-5) && (d = c), d && "cadena" == typeof G = / \ S + / g; función H (a) {var b = {}; n.each retorno (a.match (G) || [], la función (a, c) {b [c] = 0! }), b} n.Callbacks = function (a) {a = "cadena" == typeof una H (a):? n.extend ({}, a); var f && (c &&! b && (h = f.length-1, g.push (c)), la función n.each (argumentos, la función (a, b) {var c; while ((c = n.inArray (b, f, c))> - 1) f.splice (c, 1), h> = c && h- -}), esto}, tiene: function (a) {return un n.inArray (a, f)> - 1:? f.length> 0}, vacío: function () {return f && (f = []) , esto}, deshabilite: function () {return e = g = [], f = c = "", esto}, discapacitados: function () {return f}, cerradura:!! function () {retorno e = 0 , c || j.disable (), esto}, bloqueado: function () {return !! e}, fireWith: function (a, c) {return e || (c = c || [], c = [ una, c.slice c.slice ():?], g.push (c) c, b || i ()), esto}, fuego: function () {return j.fireWith (este, argumentos), este }, disparó: function () {return !! d}}; retorno j}, n.extend ({diferido: function (a) {var b = [["resolver", "terminado", n.Callbacks ("una vez memoria ")," resuelto "], [" rechazar "," fracasan ", n.Callbacks (" una vez c}, siempre: function () {return e.done (argumentos) .fail (argumentos), esto}, a continuación: function () {var a = argumentos; regresan n.Deferred (function (c) {n.each ( b, la función (b, f) {var = g n.isFunction (a [b]) && un [b]; e [f [1]] (function () {var null = un n.extend (a, d): d}}, e = {}; volver d.pipe = d.then, n.each (b, la función (a, f) {var!? Array (d), j = new Array (d), k = new f || g.resolveWith (k, c), g.promise ()}}); var I; n.fn.ready = function (a) {return c = 1;! try {c = null == a.frameElement && d.documentElement} catch (e) {} c && c.doScroll && función f () {if (! n.isReady) {try {c.doScroll ("izquierda" )} catch (b) {return a.setTimeout (f, 50)} J (), n.ready ()}} ()} volver I.promise (b)}, n.ready.promise (); var L ; para (L n (l)) break;! l.ownFirst = "0" === L, l.inlineBlockNeedsLayout = 1, n (function () {var a = d.createElement ("div");! l.deleteExpando = 0; try {eliminar a.test} catch (b) {l.deleteExpando = 1!} a = null} (); var M = function (un ) {var b = n.noData [(a.nodeName + "") .tolowercase ()], c = + a.nodeType || 1; retorno P (a, b, c) {if (void 0 === c && 1 === a.nodeType) {var d = "datos -" + b.replace (O, "- $ 1") toLowerCase ();. Si (c = a.getAttribute (d), "cadena" == typeof c = nula 0} return c} función Q (a) {var b; for (b en a) si (("datos" == b || n.isEmptyObject (a [b])) && "toJSON"! ! == b) devuelven 1!;
return 0} función R (a, b, d, e) {if (M (a)) {var f, g, h = n.expando, i = a.nodeType, j = i n.cache:? un ?, k = i una [h]: a [h] && h; si (k && j [k] && (e || j [k] .data) || vacío 0 == d || "cadena" = typeof! b) la devolución k || (k = i una [h] = c.pop (?) || n.guid ++: h), j [k] || (j [k] = i {}: {toJSON: n.noop}), ("objeto" == typeof b || "función" == typeof 0! == D && (g [n.camelCase (b)] = d), "cadena" == typeof B? (F = g [b], null == f && (f = g [n.camelCase (b) ])): f = g, f}} function S (a, b, c) {if (M (a)) {var en d b = [b] :( b = n.camelCase (b), b = b en d [b]:?? b.split ("")), e = b.length; while (E--) Eliminar d [b [e]]; si (?! c Q (d) :! n.isEmptyObject (d)) return} (c || (borrar g [h] .data, Q (g [h])) ) && (f n.cleanData ([a] ,! 0?): l.deleteExpando || g = g.window eliminar g [h]:? g [h] = nula 0)}}} n.extend ( {cache: {}, NoData: {"Applet": 0, "embed": 0, "objeto": "clsid: D27CDB6E-AE6D-11cf-96B8-444553540000"}, HasData: function (a) {return a = a.nodeType n.cache [a [n.expando]]:? A [n.expando], !! a && Q (a)}, los datos: función (a, b, c) {return R (una , b, c)}, REMOVEDATA: function (a, b) {return S (a, b)}, _ datos: función (a, b, c) {return R (a, b, c, 0)}, _removeData: function (a, b) {return S (a, b, 0!)}}), n.fn.extend ({datos: function (a, b) {var c, d, e, f = esta [ 0], g = f && f.attributes; si (void e} return "objeto" == typeof 0}, REMOVEDATA: function (a) {return this.each (function () {n.removeData (esto, a)})}}), n.extend ({cola: la función (a, b, c) {var d; retorno 0}, dequeue: function (a, b) {b = b || "fx"; var f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; n._data retorno (a, c) || ​​n._data (a, c, {vacías: n.Callbacks ("una vez !? c = 2; return "cadena" = typeof un && (b = a, a = "fx", c -), arguments.length <c n.queue (esta [0], a): void 0 == = B este:? this.each (function () {var this.each (function () {n.dequeue (esto, a)})}, clearQueue: function (a) {return this.queue (un "fx" || [])}, promesa: la función (a, b) {var c, d = 1, e = n.Deferred (), f = esto, g = this.length, h = function () {- d || e.resolveWith (f, [f])} ; "cadena" = typeof un && (b = a, a = nula 0), a = a || "fx";! while (g -) c = n._data (f [g], A + "queueHooks") , c && c.empty && (d ++, c.empty.add (h)); retorno h (), e.promise (b)}}), function () {var a; l.shrinkWrapBlocks = function () {if (null ! = a) volver a; a = 1;! var b, c, e, retorno ? (?.: \ D * \ |) (??: [EE] [+ -] \ d + |). -; 0}} () var t = / [+] \ d + / fuente, U = new RegExp ("^ (?: ([+ -]) = |) (" T + + ") ([az] *%) $", "i"), V = ["Top", "derecha", "Pie de página" "Izquierda"], W = function (a, b) {return a = b || a, "ninguno" === n.css (un "display") ||! n.contains (a.ownerDocument, a)}; la función X (a, b, c, d) {? var e, f = 1, G = 20, h = d la función () {return d.cur ()}: function () {return f = f || "0.5", k / f =, n.style (a, b, k + j);! while (f == (f = h () / i) && 1 == f && - g)} return c && (k = + k || + i || 0, e = c [1] k + (c [1] 1?) * c [2]: + c [2], d && (d. unidad = j, d.start = k, d.end = e)), e} var función Y = (a, b, c, d, e, f, g) {var h = 0, i = a.length , j = null == c; si ("objeto" === n.type (c)) {e = 0;! a (h en c) Y (a, b, h, c [h] ,! 0 , f, g)} else if (void 0! == d && (e = 0, n.isFunction (d) || (g = 0), j && (g? (b.call (a, d), b = null) :( j = b, b = function (a, b, c) {j.call retorno (n (a), c)})), b)) de (; i> h; h ++) b (a [h], c, g d: d.call (a [h], h, b (a [h] c)),?); retorno ca (a) {var ! c} function () {var a = d.createElement ("div"), b = d.createDocumentFragment (), c = d.createElement ("entrada"); a.innerHTML = "<link /> <table> <table /> <a href='/a'> un </a> <input da = {opción: [1, "<select ea (a, b) {var c, d, e = 0, f = "undefined" = typeof a.getElementsByTagName a.getElementsByTagName (b || "*"):!?! "indefinido" = typeof a.querySelectorAll? a.querySelectorAll (b || "*"): void void 0 === b || b && n.nodeName (a, b) n.merge ([a], f):?! f} function f bis (a, b) {for (var c, d = 0; null = (c = a [d]); d ++) n._data (! c, "globalEval", b || n._data (b [d] ", globalEval"))} var ga = / <| & # \ w +; /, ha = / <tbody / i; función de AI (a) {Z.test (a.type) && (a.defaultChecked = a.checked)} ja función (a, b, c, d, e) {for (var i = null, p} function () {var b, c, e = d.createElement ("div"), porque (b en {presentar:!!! 0, cambie: 0, focusIn: 0})! c = "en" + b, (l [b] = c en a) || (e.setAttribute (c, "t"), l [b] = e.attributes [c] .expando === 1!); e = null} (); var pa () {return 0} function qa () {return! 1} function ra () {try {return d.activeElement} catch (a) {}} sa función (a, b, c, d, e, f ) {var g, h; if (! "objeto" == typeof b) {"cadena" = typeof c && (d = d || c, c = 0 nula); for (h en b) sa (a, h , c, d, b [h], f); volver a} si (null == == d && nula e (e = c, d = c = 0 vacío?): null == e && ("string" == typeof ? c (e = d, d = nula 0) :( e = d, d = c, c = nula 0)), e === 1) e = qa;! else if (e) volver a; retorno 1 === f && (g = e, e = function (a) {return n || un vacío && n.event.triggered === a.type? k [o])} else para (o en k) n.event.remove (a, o + b [j], c, d, 0);! n.isEmptyObject (k) && (borrar r.handle, n ._removeData (a, "eventos"))}}, disparador: function (b, c, e, f) {var n.Event (q, "objeto" == typeof b && b), b.isTrigger = f 2: 3, b.namespace = r.join ("."), b.rnamespace = b.namespace nueva RegExp ("? (^ | \\). "+ r.join (" \\ (:.?.. * \\ |) ") +" (. \\ | $) "): null, b.result = vacío 0, m && (e [h] = m)} return b.result}}, expedición: function (a) {a = n.event.fix (a); var 0! == D && (a.result = d) ===! 1 && (a.preventDefault (), a.stopPropagation ()))} volver k.postDispatch && k.postDispatch.call (esto, a), a.result} }, manipuladores: función (a, b) {var ",vacío h <b.length && g.push ({elem: esto, manipuladores: b.slice (h)}), g}, fijar: function (a) {if (a [n.expando]) devuelve una; var n.Event (g), b = e.length, mientras que (b -) c = e [b], una [c] = g [c]; retorno burbujas cancelable detalle ctrlKey currentTarget eventPhase metakey relatedTarget shiftKey vista timeStamp objetivo que ".split (" "), fixHooks: {}, keyHooks: {props:" charCode carbón keyCode tecla ".split (" "), filtro: la función (a, b) {return null == a.which && (a.which = null = b.charCode b.charCode:!? b.keyCode), un}}, mouseHooks: {props: "buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement ".split (" "), el filtro: function (a, b) {var c, e, f, g = b.button, h = b.fromElement; retorno this.focus () ,! 1} catch (a) {}}, delegateType: "focusIn"}, mancha: {gatillo: function () {devolver este ra === () && this.blur (this.blur ( ) ,! 1): void 0}, delegateType: "focusOut"}, haga clic en: {gatillo: function () {return n.nodeName (this, "entrada") && "casilla" === this.type && this.click? (this.click () ,! 1): void 0}, _ por defecto: function (a) {return n.nodeName (a.target, "a")}}, beforeunload: {postDispatch: function (a) {void d = n.extend (nueva d = "on" + b; a.detachEvent && ("undefined" == typeof un [d] && (a [d] = null), a.detachEvent (d, c))}, n.Event = function (un , b) {return este instanceof n.nodeName (esta "forma",) ?! 1: void n.event.add (esto "click._submit keypress._submit", la función (a) {var b = a.target, c = n.nodeName ( b, "entrada") || n.nodeName (b, "botón") n.prop (b, "forma"): void n.nodeName (this, "forma") ?! 1: void n.event.remove (esto "._ enviar")}}), l.change || (n.event.special.change = {configuración: función (){regreso n.event.add (esto "beforeactivate._change", la función (a) {var b = a.target; retorno 0}, desmontaje: function () {return c = function (a) {n.event.simulate (b, a.target, n.event.fix (a))}; n.event.special [b] = {configuración: function () {var sa (esto, a, b, c, d)}, uno: la función (a, b, c, d) {sa retorno (esto, a, b, c, d, 1)}, off: la función (a, b, c) {var d, e; si (a && && a.handleObj a.preventDefault) de retorno a) {for (e en a) this.off (e, b, a [e]); devuelva este} return (b === 1 || "función" == typeof b) && (c = b,! ! b = nula 0), c === 1 && (c = q), this.each (function () {n.event.remove (esto, a, c, b)})}, disparador: la función (a, b) {return this.each (function () {n.event.trigger (a, b, este)})}, triggerHandler: function (a, b) {var c = esta [0]; retorno c n?. event.trigger (a, b, c, 0!): void 0}}); var ta = / jQuery \ d + = "(nulo ?: | \ d +)" / g, ua = new Ca (a, b) {return Da (a) {return a.type = (null! == N.find.attr (a, "tipo")) + "/" + a.type, un} function Ea (a) {var b = ya. ? exec (a.type); retorno b = a.type b [1]: a.removeAttribute ("tipo"), un} function Fa (a, b) {if (1 === b.nodeType && n.hasData ( a)) {var c, d, e, f = n._data (a), g = n._data (b, f), h = f.events; si (h) {borrar g.handle, g.events = {}; for (c en Ga (a, b) {var en Ha (a, b, c, d) {b = f.apply ([], b); var e, g, h, i, j, k, m = 0, o = a.length, p = o- 1, q = b [0], r = n.isFunction (q); if (! r || o> && "cadena" == typeof q && && l.checkClone xa.test (q) 1) retorno a.each (función ( e) {var a} función de Ia (a, b, c) {for (var a} n.extend ({htmlPrefilter: function (a) {a.replace retorno (va, "<$ 1> </ $ 2>")}, clon: function (a, b, c) {var Fa (a, f); retorno d = ea (f, "script"), D.Longitud> 0 && fa (d, i && ea (un "guión",)!), D = h = e = null, f}, CleanData : function (a, b) {for (var en g.events) m [e] n.event.remove (d, e):? n.removeEvent (d, e, g.handle); j [f] && (borrar j [f], k || " undefined "== typeof d [i] = nula 0 d.removeAttribute:? d.removeAttribute (i), c.push (f))}}}), n.fn.extend ({domManip: Ja, separe: función (a) {return Ia (esto, a, 0!)}, quite: function (a) {return Ia (esto, a)}, el texto: la función (a) {return Y (esto, la función (a) {return vacío Ha (esto, los argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = Ca (esto, a); b.appendChild (a)}})}, anteponga: function () {return Ha (esto, los argumentos, la función (a) {if (1 === === this.nodeType || 11 || 9 this.nodeType === this.nodeType) {var b = Ca (esto, a); b.insertBefore (a, b.firstChild)}})}, antes: function () {return esto}, clon: function (a, b) {return una = null == 1:?! a, b = null == b a: b, this.map (function () {n.clone retorno (esta , a, b)})}, html: function (a) {return Y (esto, la función (a) {var b = esta [0] || {}, c = 0, d = this.length; si ( void 0 === a) la devolución 1 === b.innerHTML.replace b.nodeType (ta, "?"): void 0; si ("cadena" == typeof a = []; volver Ha (esto, los argumentos, la función (b) {var this.pushStack (e)}}); var Ja, Ka = {HTML: "bloque", CUERPO: "bloque"}; La función de (a, b) {var c = n (b.createElement (a)). appendTo (b.body), d = n.css (c [0], "display"); c.detach return (), d} function Ma (a) {var b = d, c = Ka [a]; volver c || (c = La (a, b), "ninguno"! == c && c || (Ja = (Ja || n ("<'0' = ancho iframe frameborder =" 0 " Na = / ^ margen /, Oa = new RegExp ("(^" T + + ") (px ?!) [az%] + $", "i"), Pa = function (a, b, c, d) {var e, f, g = {}; para (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []), porque (f en b) a.style [f] = g [f]; volver e}, Qa = d.documentElement;! function () {var nula == b && k (), f}, boxSizingReliable: function () {return null == b && k (), e}, pixelMarginRight: function () {return null == b && k (), c}, pixelPosition: function () { devolver null == b && k (), b}, reliableMarginRight: function () {return null == b && k (), g}, reliableMarginLeft: function () {return null == b && k (), h}}); la función k () {var Ra, Sa, Ta = / ^ (arriba | right | abajo | izquierda) $ /;? A.getComputedStyle (Ra = function (b) {var c = b.ownerDocument.defaultView; retorno c.opener || (c = a), c.getComputedStyle (b)}, Sa = function (a, b, c) {var d, e, f, g, h = a.style; retorno c = c || Ra (a), g = ? c c.getPropertyValue (b) || c [b]: void 0 === g g: g + ""}): Qa.currentStyle && (Ra = function (a) {return a.currentStyle}, Sa = function (a, b, c) {var d, e, f, g ?, h = a.style; retorno c = c || Ra (a), g = c c [b]: void ? 0 === g g: g + "" || "auto"}); funciona Ua (a, b) {return {get: function () {return a () void borrar this.get: (this.get? = b) .apply (esto, argumentos)}}} var Va = / alfa \ ([^)] * \) / i, Wa = / opacidad \ s * = \ s * ([^)] *) / i , Xa = / ^ (ninguno |?!. mesa (- c [ea]) +) /, Ya = new bb (a) {if (A en la ab) de regreso a; b = var a.charAt (0) .toUpperCase () + a.slice (1), c = _a.length; while (c -) si (a = _a [c] + b, una en ab) volver a} cb función (a, b) {for (var a} db función (a, b, c) {var d = Ya.exec (b); retorno d Math.max (0, d [1] - (c || 0)) + (d [2] |? | "px"): b} function eb (a, b, c, d, e) {for (var g} function fb (b, c, e) {var g; f = i && (l.boxSizingReliable () || g === b.style [c]), g = parseFloat (g) || 0} return 0 === c) retorno g && "get" en g && vacío 0 == (e = g.get (a, 1, d!)) E:!? I [b]; si (f = typeof g && void 0 === (c = g.set (a, c, d))))) tratan {i [b] = c} catch (j) {}}}, css: function (a, b, c, d) {var e, f, g, h = n.camelCase (b); retorno b = n.cssProps [h] || (n.cssProps [h] = bb (h) || h), g = n .cssHooks [b] || n.cssHooks [h], g && "get" en g && (f = g.get (a, 0, c)), nula 0 === f && (f = S (a, b , d)), "normal" === f && b en c Xa.test (n.css (un "display")) && 0 === a.offsetWidth Pa (a, Za, function () {fb retorno (a, b, d)}):?? fb (un , b, d): void 0}, establezca: function (a, c, d) {var e = && d Ra (a); retorno "+ e)}}), n.cssHooks.marginRight =Ua (l.reliableMarginRight, la función (a, b) {return b Pa (a, {display: "inline-block"}, Sa, [a, "marginRight"]): void 0}), n.cssHooks. marginLeft = Ua (l.reliableMarginLeft, la función (a, b) {return b?(parseFloat(Sa(a,"marginLeft"))||(n.contains(a.ownerDocument,a)?a.getBoundingClientRect().left-Pa(a,{
marginLeft: 0}, la función () {return a.getBoundingClientRect ()} izquierda):. 0)) + "px": void d = 0, e = {}, f = "cadena" == typeof c c.split (""):? [c]; 4> d; d ++) e [a + V [d] + b] = f [d] || f [d-2] || f [0]; volver e}}, Na.test (a) || (n.cssHooks [a + b] .set = db)}), n. fn.extend ({css: function (a, b) {return Y (esto, la función (a, b, c) {var d, e, f = {}, g = 0; si (n.isArray (b) ) {for (d = Ra (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d), f retorno } volverá vacía 0 == c n.style (a, b, c):? n.css (a, b)}, a, b, arguments.length> 1)}, show: function () {cb retorno (esto, 0!)}, ocultar: function () {cb retorno (este)}, de palanca: function (a) {return "booleano" == typeof a a this.show ():?? this.hide () : this.each (function () {W (esto) n (esto) .show ():? n (esto) .hide ()})}}); gb función (a, b, c, d, e) {return nueva a = gb.propHooks [this.prop]; devolver un && a.get a.get (este):? gb.propHooks._default.get (este)}, ejecute: function (a) {var b, c = gb.propHooks [this.prop]; retorno b; retorno hb, ib, jb = / ^ (?: alternar | presentación | ocultar) $ /, = kb / queueHooks $ /; función de libras () {return a.setTimeout (function () {hb = nula 0}), hb = n.now ()} mb función (a, b) {var c, d = {altura: a}, e = 0; para (b = b 1: 0; 4> e; e + = 2-b) c = V [e], d ["margen" + c] = d ["relleno" + c] = a; retorno b && (d.opacity = d.width = a), d} nb función (a, b, c ) {for (var d} function ob (a, b, c) {var b || "ancho" en en b) si (E = b [d], jb.exec (e)) {if (borrar b [d], f = f || "alternar" === e, e === (q? "ocultar ":" show ")) {if ("!!! espectáculo "== e || r || vacío 0 === r [d]) continuar; q = 0} o [d] = r && r [d] | | n.style (a, d)} else j = 0 nula; si (n.isEmptyObject (o)) "en línea" === ("ninguno" === j Ma (a.nodeName): j) && (p.display = j); else {r "escondido" en? b; n._removeData (a, "fxshow"), porque (b en o) n.style (a, b, o [b])}); for (d en o) g = nb (r q [d ]: 0, d, m), d en r || (r [d] = g.start, q && (g.end = g.start, g.start = "width" === d || "altura" ? === d 1: 0))}} function pb (a, b) {var c, d, e, f, g, porque (c en a) si (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, eliminar un [c]), g = n.cssHooks [d], g && "ampliar" en g) {f = g.expand (f), eliminar un [d]; para (c en f) c en a || (a [c] = f [c], b [c] = e)} else b [d] = e} function qb (a, b, c) {var d, e, f = 0 g, . = qb.prefilters.length, h = n.Deferred () siempre (function () {delete i.elem}), i = function () {if (e) volver 1;! for (var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); j.tweens.push retorno (d), d}, parada: function ( b) {var c = 0, d = b j.tweens.length: 0; si (e) volver esto, porque (e = 0, d> c, c ++) j.tweens [c] .run (1 );regreso n.isFunction (d.stop) && (n._queueHooks (j.elem, j.opts.queue) .Stop = n.proxy (d.stop, d)), d; retorno c = this.createTween (a, b); retorno d = un "objeto" && == typeof d.duration = n.fx.off 0:?? "número" == d.duration typeof d.duration: d.duration en e = n.isEmptyObject (a), f = n.speed (b, c, d), g = function () {var b = qb (esto, n.extend ({}, a), f), (e || n._data (this, "terminar")) && b.stop (0)}; volver g.finish = g, e || f.queue === 1 this.each (g): esto!?. cola (f.queue, g)}, pare: function (a, b, c) {var d = function (a) {var b = a.stop; eliminar a.stop, b (c)}; volver "cadena "! = typeof un && (c = b, b = a, a = nula 0), b && a! ==! 1 && this.queue (a ||" fx ", []), this.each (function () {var b !! = 0, e = null = a && a + "queueHooks", f = n.timers, g = n._data (este), si (e) g [e] && g [e] .Stop && d (g [e]); más para (e en a! ==! 1 && (a = a || "fx"), this.each (function () {var c.finish})}}), n.each (["cambiar", "show", "ocultar"], la función (a, b) {var c = n.fn [b]; n.fn [b] = function (a, d, e) {return null == a || "booleano" == typeof this.animate (b, a, c, d)}}), n.timers = [], n.fx.tick = function () {var ? b = n.fx n.fx.speeds [b] || b: b, c = c || "fx", this.queue (c, la función (c, d) {var e = a.setTimeout (c , b); d.stop = function () {a.clearTimeout (e)}})}, function () {var </ link> <table> </ table> <a href='/a'> un </a> <input rb = / \ r / g; n.fn.extend ({val: function (a) {var b, c, d, e = esta [0]; {if (arguments.length) retorno d = n.isFunction ( a), this.each (function (c) {var e; 1 === this.nodeType && (e = d a.call (esto, c, n (este) .val ()):? a, == null e e = "?": "número" == typeof e e + =? "": n.isArray (e) && (e = n.map (e, la función (a) {return null == un ""?: a + ""})), b = n.valHooks [this.type] || n.valHooks [this.nodeName.toLowerCase ()], b && "set" en b && vacío 0! == b.set (esto, e, "valor") || (this.value = e))}); if (e) de retorno b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "consiguen "en b && vacío 0 == (c = b.get (e," valor ")) c:? (c = e.value," cadena "== typeof c c.replace (rb,?" "): null == c "": c)}}}), n.extend ({valHooks: {opción: {get: function (a) {var b = n.find.attr (a, "? valor"); return null ! = b b:? n.trim (n.text (a))}}, seleccione: {get: function (a) {for (var b; g.push (b)} return g}, establezca: function (a, b) {var d.selected = 1;! devolución n.isArray (b) a.checked = n.inArray (n (a) .val (), b)> - 1:? void 0}}, l.checkOn || (n.valHooks [esto] .get = función (a) {return null === a.getAttribute ("valor") "en": a.value?})}); var Y (esto, n.attr, a, b, arguments.length> 1)}, removeAttr: function (a) {return this.each (function () {n.removeAttr (esto, a)})}}), n.extend ({attr:!!! función (a, b, c) {var d, e, f = a.nodeType; si (3 == f && 8 == f && 2 == f) la devolución "indefinido" == typeof 0 == c nula === c nula n.removeAttr (a, b):?!? E && "set" en e && vacío 0 == (d = e.set (a, c, b)) d :( a.setAttribute (b, c + ""), c): e && "Entérate" en e && nula == (d = e.get (a, b)) d:? (d = n.find.attr (a, b ), null == d nula 0: d))}, attrHooks: {type: {conjunto: la función (a, b) {if (l.radioValue && "radio" === b && n.nodeName (a, "de entrada ")) {var c = a.value; volver a.setAttribute (" tipo ", b), c && (a.value = c), b}}}}, removeAttr: function (a, b) {var c = ub [b] || n.find.attr;!? xb && wb || vb.test (b) ub [b] = function (a, b, d) {var e, f; retorno d || (f = ub [b], ub [b] = E, E = null = c (a, b, d) b.toLowerCase ():!? nula, ub [b] = f), e}: ub [b] = function (a, b, c) {return c? nula n.nodeName (a, "entrada") vacío (a.defaultValue = b):? sb && sb.set (a, b, c)}}), wb || (sb = {conjunto: function (a, b, c ) {var d = a.getAttributeNode (c); retorno 0}}, ub.id = ub.name = ub.coords = function (a, b, c) {var d; c retorno void 0: (d = a.getAttributeNode (b)) && "" ==?! ? d.value d.value: null}, n.valHooks.button = {get: function (a, b) {var c = a.getAttributeNode (b); volver c && c.specified c.value: void 0}}})), l.style || (n.attrHooks.style = {get: function (a) {return a.style.cssText || vacío 0}, establezca: function (a, b) {return un .style.cssText = b + ""}}); var Y (esto, n.prop, a, b, arguments.length> 1)}, removeProp: function (a) {return a = n.propFix [a] || a, this.each (function () {try { esto [a] = 0 vacío, eliminar este [a]} catch (b) {}})}}), n.extend ({prop: function (a, b, c) {var d, e, f = a .nodeType; if (!!! 3 == f && 8 == f && 2 == f) return 1 === f && n.isXMLDoc (a) || (b = n.propFix [b] || B, E = n.propHooks [b]), nula 0 == c e && "set" en e && vacío 0 == (d = e.set (a, c, b)) d:!?!? A [B] = c: e && "get" en e && nula == (d = e.get (a, b)) d:? A [B]}, propHooks: {tabIndex: {get: function (a) {var b = n.find.attr (a, "tabindex"); retorno a.getAttribute (b, 4)}}}), l.optSelected || (n.propHooks.selected = {get: function (a) {var b = a.parentNode; retorno Ab = / [\ t \ r \ n \ f] / g; función Bb (a) {n.attr retorno (a, "clase") || ""} n.fn.extend ({addClass: function (un ) {var b, c, d, e, f, g, h, i = 0; si (n.isFunction (a)) volver this.each (function (b) {n (este) .addClass (a.call (esto, b, Bb (este)))}); si ("cadena" == typeof un && a) {b = a.match (G) || []; mientras (c = esta [i ++]) si (e = Bb (c), d = 1 === c.nodeType && ("" + e + "") .Colocar (Ab, "")) {g = 0, mientras que (f = b [g ++]) d.indexOf ( "" + f + "") <0 && (d + = f + ""); h = n.trim (d), e == h && (c n.attr, "clase", h)}} devolver este}, removeClass: función (a) {var b, c, d, e, f, g, h, i = 0; si (n.isFunction (a)) regrese this.each (function (b) {n (este) .removeClass ( a.call (esto, b, Bb (este)))}); if (! arguments.length) volver this.attr ("clase", ""); si ("cadena" == typeof un && a) {b = a.match (G) || []; while (c = esta [i ++]) si (e = Bb (c), d = 1 === c.nodeType && ("" + e + "") .Colocar (Ab , "")) {g = 0, mientras que (f = b [g ++]), mientras que (d.indexOf ("" + f + "")> - 1) d = d.replace ("" + f + "", " "!); h = n.trim (d), e == h && (c n.attr," clase ", h)}}} devolver este, toggleClass: function (a, b) {var typeof un c =; retorno "booleano" == typeof b, c, d = 0, b = "" + a + "", mientras que (c = esta [d ++]) si (1 === c.nodeType && ("" + Bb (c) + "") .Colocar ( Ab, "") .indexOf (b)> - 1) return 0;! devolver 1}}), n.each ("enfoque desenfoque focusIn carga focusOut desplazamiento de cambio de tamaño de descarga, haga clic dblclick mousedown mouseup mousemove mouseover mouseout MouseEnter mouseleave cambio seleccione presentar keydown keyup pulsación error contextual ".split (" "), la función (a, b) {n.fn [b] = function (a, c) {arguments.length retorno> 0? this.on (b, null, un , c): this.trigger (b)}}), n.fn.extend ({vuelo estacionario: function (a, b) {return this.mouseenter (a) .mouseleave (b || a)}}); var a.JSON.parse (b + ""); var c, d = null, e = n.trim (b + "");! de retorno e && n.trim (e.replace (Fb, la función (a, b, e, f) {return c && b && (d = 0), 0 === d a:?!! (c = e || b, d + = f- e ",")}?)) Función ("retorno" + e) (): n.error ("JSON válido:" + b)}, n.parseXML = function (b) {var c, d; if (!! b || "cadena" = typeof b) return null; try { a.DOMParser? (d = new a.DOMParser, c = d.parseFromString (b, "text / xml")) :( c = new a.ActiveXObject ("Microsoft.XMLDOM"), c.async = "false" , c.loadXML (b))} catch (e) {c = nula 0} return c && && c.documentElement c.getElementsByTagName ("parsererror") Longitud || n.error ("XML no válido:"!. + b), c . (.? *);} var Gb = / # * $ /, Hb = / ([? &]) _ = [^ &] * /, Ib = / ^: [ ! Sb (a) {retorno de la función (b, c) {"cadena" = typeof b && (c = b, b = "*"); var Tb (a, b, c, d) {var e = {}, f = a === Ob; función g (h) {var i; vuelta de correo [h] = 0, n.each (a [h! ] || [], la función (a, h) {var j = h (b, c, d);?!?! regresan "cadena" = typeof j || f || e [j] i (i = j ): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} return g (b.dataTypes [0]) || e ["*"] && g ("! * ")} function Ub (a, b) {var C, D, E = n.ajaxSettings.flatOptions || {};! a (d en b) vacío 0 == b [d] && ((e [d ] a:?! c || (c = {})) [d] = b [d]); volver c && n.extend (0, a, c), un} function Vb (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; mientras ("*" === i [0]) i.shift (), nula 0 === e && (e = a. mimeType || b.getResponseHeader ("Content-Type")); si (e) para (g en h) si (h [g] && h [g] .test (e)) {i.unshift (g); ruptura } if (i [0] en c) f = i [0]; (! i [0] || a.converters [g + "" + i [0]]) else {for (g en c) {if { f = g; ruptura} d || (d = g)} f = f || d} return f (f == i [0] && i.unshift (f), c [f]!): void 0} funcionar Wb (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (), si (k [1]) para (g en si ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ,! g) de (e en j) si (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["* try {b = g (b)} catch (l) {return {estado: "parsererror", error:? g l: "Sin la conversión de" + i + "para charset = UTF-8 ", acepta: {" * ": Pb, texto:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json , texto ": String", html texto ": 0," json texto ": n.parseJSON," xml texto ": n.parseXML}, flatOptions: {url: 0, el contexto: 0}}, ajaxSetup: función (a, b) {return b && (c = b, b = 0 nula), c = c || {}; var b, y si (2 === u) {if (k!) {k = {}, mientras que (b = Ib.exec (g)) k [b [1] .tolowercase ()] = b [2]} b = k [a.toLowerCase ()]} devolver null == b nula:? b}, getAllResponseHeaders: function () {return 2 === u g: null}, setRequestHeader: function (a, b) {var c = a.toLowerCase (); volver u || (a = t [c] = t [c] || a, = s [a] b), esto}, overrideMimeType: function (a) {return u || (l.mimeType = a), esto}, StatusCode: function (a) {var b; si (a) si (2> u) por (b en a) r [b] = [r [b], una [ b]]; w.always demás (a [w.status]); regresan este}, abortar: function (a) {var b = a || v; retorno l.data && (l.data = n.param (l.data, l.traditional)), Tb (Nb, l, c, w), 2 === u) de retorno "Pb + +"; q = 0,01 ":" "): l.accepts [" * "]); for (e en w.abort (); v = "abortar", porque (e x; y (-1, x)}} else y (-1, "No Transporte"); función y (b, c, d, e) {var k, s, t, v, x, y = c; 2! == u && (u = 2, h && a.clearTimeout (h), j = void w}, getJSON: function (a, b, c) n.get {return (a, b, c, "json")}, getScript: function (a, b) {n.get retorno (a, 0 nula, b, "script")}}), n.each (["get", "post"], la función (a, b) {n [b] = function (a, c, d, e) {return n. isFunction (c) && (e = e || d, d = c, c = vacío this.each (function (b) {n (esto) .wrapAll (a.call (esto, b))}), si (esta [0]) {var a = este, mientras que (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; volver a}) append (este)}} devuelva este, wrapInner:. función (a) {return n.isFunction ( a) this.each (function (b) {n (este) .wrapInner (a.call (esto, b))}):? this.each (function () {var b = n (este), c = b .contents (); c.length c.wrapAll (a):? b.append (a)})}, envoltura: function (a) {var b = n.isFunction (a); regresan this.each (function ( c) {n (? esto) .wrapAll (a.call b (esto, c): a)}: function () {return)}, desenvuelva Xb (a) {return a.style && a.style.display || n.css (un "display",)} function cc (a, b, c, d) {var e;? si (n.isArray (b)) n.each (b, la función (b, e) {c || $ b.test (a) d (a , e): cc (a + "[" + ("objeto" == typeof e && null = b e:!? "") + "]", e, c, d)}); else if (c || "objeto "! == n.type (b)) d (a, b); más para (e en b) cc (a +" ["+ e +"] ", b [e], c, d)} n.param = function (a, b) {var . para (c en a) cc (c, a [c], b, e); volver d.join ("&") reemplazará (Zb, "+")}, n.fn.extend ({serializar: función () {return n.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var a = n.prop (this, "elementos"), devuelve un n?. MakeArray (a):. esta}) filtrar (function () {var a = this.type; retorno c = n (este) .val (); retorno 0! == A.ActiveXObject? Function () {retorno dc = 0, ec = {}, fc = n.ajaxSettings.xhr ();! a.attachEvent && a.attachEvent ("onunload", function () {for (var a en ec) ec [a] (void 0, 0 )}), l.cors = !! fc y & "withCredentials" en fc, fc = l.ajax = !! fc, fc && n.ajaxTransport (función (b) {if (b.crossDomain || l.cors) {var c; retorno {enviar: función (d, e) {var f, g = b.xhr (), h = ++ cc; si (g.open (b.type, b.url, b.async, b.username, b.password), b.xhrFields ) para (f en en d) void 0 == d [f] && g.setRequestHeader (f, d [f] + "");! g.send (b.hasContent && B.Data || null), c = function (a, d) { var f, i, j; if (! c && (d || 4 === g.readyState)) si (borrar ec [h], c = 0 vacío, g.onreadystatechange = n.noop, d) 4 == g.readyState && g.abort (); else {j = {}, f = g.status, "cadena" == typeof 0, 0)}}}}); función gc () {try {return new a.XMLHttpRequest} catch (b) {}} function hc () {try {return nueva application / javascript, application / ECMAScript, application / x-ECMAScript "}, contenidos: {script: / \ b (?: java | ECMA) guión \ b /}, convertidores: {" escritura de texto ": function (a) { volver n.globalEval (a), un}}}), n.ajaxPrefilter ("guión", la función (a) {void ?!? 0, 0)}}}}); ic var = [], jc = / (=) \ (= & | $) | \ \ /; n.ajaxSetup ({jsonp:?? "Devolución de llamada", jsonpCallback: function () {! var a = ic.pop () || n.expando + "_" + Db ++; devuelva este [a] = 0, a}}), n.ajaxPrefilter ("json jsonp", función ( b, c, d) {var e, f, g, h = b.jsonp == 1 && (jc.test (b.url) "url":!? "cadena" == typeof json "] = function () {return g || n.error (e +" no se llamaba "), g [0]}, b.dataTypes [0] =" json ", f = a [e], una [ e] = function () {g = argumentos}, d.always (function () {void 0}), "script"):!! Nula 0}), l.createHTMLDocument = function () {if (d.implementation.createHTMLDocument) devuelve 1; var a = d.implementation.createHTMLDocument (""); retorno a) nula rentabilidad; (d.implementation.createHTMLDocument c = b, b = 1), b = b || (l.createHTMLDocument (""?!) "booleano" == typeof b &&: d); var e = x .exec (a), f = c && [];!? vuelta de correo [b.createElement (e [1])] :( e = ja ([a], b, f), f && f.length && n (f) .Remove (), n.merge ([], e.childNodes))}; var kc = n.fn.load;! n.fn.load = function (a, b, c) {if ("cadena" = typeof un && kc ) volver kc.apply (este, argumentos); var d, e, f, g = esto, h = a.indexOf (""); retorno h> -1 && (d = n.trim (a.slice (h, ? a.length)), a = a.slice (0, h)), n.isFunction (b) (c = b, b = nula 0): b && "objeto" == typeof this.on (b, a)}}), n.expr.filters.animated = function (a) {return n.grep (n.timers, la función (b) {return un b.elem ===}). longitud}; lc función (a) {return ? b b.using.call (a, m): l.css (m)}}, n.fn.extend ({offset: la función (a) {if (arguments.length) de retorno void 0 === una? esto: this.each (function (b) {n.offset.setOffset (esto, a, b)}); var b, c, d = {superior: 0, izquierda: 0}, e = esta [0], f = e && e.ownerDocument; si (f) de retorno b = f.documentElement, n.contains (b, e) ("undefined" = typeof?! this.map (function () {var a || Qa})}}), n.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, la función (a, b) {var c = / Y / .test (b); n.fn [a] = function (d) {return Y (esto, la función (a, d, e) {var f = lc (a); volver vacío 0 === e f b en?
n.cssHooks [b] = Ua (l.pixelPosition, la función (a, c) {return c? (c = S (a, b), Oa.test (c)? n (a) .position () [b ] + "px": c): void f = arguments.length && (c || "booleano" = typeof d!), g = c || (d === 0 || e === 0 "margen":!? "frontera"); volver Y (esto, la función (b, c, d) {var e; retorno ? 0 === d n.css (b, c, g):? N.style (b, c, d, g)}, b, f d: void 0, f, null)}})}), n.fn.extend ({bind: function (a, b, c) {return this.on (a, nula, b, c)}, desenlaza: function (a, b) {return this.off (a, nula , b)}, delegado: function (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b, c) {return 1 === argumentos .length this.off (a, "**"):? this.off (b, a || "**", c)}}), n.fn.size = function () {return this.length} , n.fn.andSelf = n.fn.addBack, "función" == typeof definir && && define.amd define ("jQuery", [], la función () {return n}); mc var = a.jQuery, nc = a. $; volver n.noConflict = function (b) {return un $ === n && (a $ = nc.), b && a.jQuery === n && (a.jQuery = mc), n.}, b || ( . a.jQuery = a $ = n), n});